// Package acrypt provides an interface similar to the bcrypt library interface,
// but uses the Argon2id hashing algorithm for improved security. It also
// provides a slightly simpler interface, convenient for implementations that do
// not need to use the Bcrypt one.
package acrypt

import (
	"crypto/rand"
	"crypto/subtle"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"regexp"
	"strconv"

	"golang.org/x/crypto/argon2"
)

// HashID exposes a constant identifier that can be used to refer to hashes
// generated by this library. Every hash will also be prefixed with this value,
// allowing clients to quickly test hashes for type.
const HashID = "$argon2id"

// Config contains the configuration parameters used for the Argon2id algorithm.
type Config struct {
	MemoryKB    uint32
	Times       uint32 // iterations
	Parallelism uint8
	SaltLength  uint32
	KeyLength   uint32
}

// DefaultConfig defines the Argon2 hashing parameters used by default. Values
// for several of the parameters are recommended in the RFC draft:
// https://tools.ietf.org/html/draft-irtf-cfrg-argon2-04#section-3.1
//
// The default configuration is exposed, so the values can be updated at the
// package level, allowing developers to customize the configuration while still
// leveraging the simpler API.
var DefaultConfig = &Config{
	MemoryKB:    1 << 16, // 64MB (in kibibytes, so 1<<10)
	Times:       3,
	Parallelism: 2,
	SaltLength:  16,
	KeyLength:   32,
}

// Hash a password string using the package level `DefaultConfig`.
func Hash(password string) ([]byte, error) {
	return GenerateFromPassword([]byte(password), DefaultConfig)
}

// GenerateFromPassword returns a hash generated using the configuration
// parameters provided for the Argon2id hashing algorithm. If the config param
// is nil, then the default config values will be used.
func GenerateFromPassword(password []byte, cfg *Config) ([]byte, error) {
	if cfg == nil {
		cfg = DefaultConfig
	}

	salt := make([]byte, cfg.SaltLength)
	_, err := io.ReadFull(rand.Reader, salt)
	if err != nil {
		return nil, fmt.Errorf("failed to generate salt for hash: %v", err)
	}

	hash := argon2.IDKey(
		password,
		salt,
		cfg.Times,
		cfg.MemoryKB,
		cfg.Parallelism,
		cfg.KeyLength,
	)

	h := fmt.Sprintf(
		"$argon2id$v=19$m=%d,t=%d,p=%d$%s$%s",
		cfg.MemoryKB,
		cfg.Times,
		cfg.Parallelism,
		base64.RawStdEncoding.EncodeToString(salt),
		base64.RawStdEncoding.EncodeToString(hash),
	)
	return []byte(h), nil
}

// Verify compares an Acrypt hashed password with its possible plaintext string
// equivalent.
func Verify(hashedPassword []byte, password string) bool {
	return CompareHashAndPassword(hashedPassword, []byte(password)) == nil
}

// CompareHashAndPassword compares an acrypt hashed password with its possible
// plaintext equivalent. It returns nil upon success.
func CompareHashAndPassword(hashedPassword, password []byte) error {
	cfg, salt, hash, err := parseHashedPassword(hashedPassword)
	if err != nil {
		return fmt.Errorf("unable to confirm password match: %w", err)
	}

	hash2 := argon2.IDKey(
		password,
		salt,
		cfg.Times,
		cfg.MemoryKB,
		cfg.Parallelism,
		cfg.KeyLength,
	)

	if subtle.ConstantTimeCompare(hash, hash2) != 1 {
		return errors.New("unable to confirm password match")
	}

	return nil
}

// conventional pattern for exposing hash:
//
//	ref: https://github.com/P-H-C/phc-winner-argon2#usage
var re = regexp.MustCompile(`(\$.+)\$v=(\d+)\$m=(\d+),t=(\d+),p=(\d+)\$([^\$]+)\$([^\$]+)`)

func parseHashedPassword(hashedPassword []byte) (cfg *Config, salt, hash []byte, err error) {
	parts := re.FindStringSubmatch(string(hashedPassword))

	if len(parts) != 8 {
		return nil, nil, nil, errors.New("invalid hash (format)")
	}

	if parts[1] != HashID {
		return nil, nil, nil, errors.New("invalid hash (type)")
	}

	if parts[2] != "19" {
		return nil, nil, nil, errors.New("invalid hash (v)")
	}

	m, err := strconv.ParseUint(parts[3], 10, 32)
	if err != nil {
		return nil, nil, nil, fmt.Errorf("invalid hash (m): %w", err)
	}

	t, err := strconv.ParseUint(parts[4], 10, 32)
	if err != nil {
		return nil, nil, nil, fmt.Errorf("invalid hash (t): %w", err)
	}

	p, err := strconv.ParseUint(parts[5], 10, 8)
	if err != nil {
		return nil, nil, nil, fmt.Errorf("invalid hash (p): %w", err)
	}

	salt, err = base64.RawStdEncoding.DecodeString(parts[6])
	if err != nil {
		return nil, nil, nil, fmt.Errorf("unable to parse hash: %w", err)
	}

	hash, err = base64.RawStdEncoding.DecodeString(parts[7])
	if err != nil {
		return nil, nil, nil, fmt.Errorf("unable to parse hash: %w", err)
	}

	cfg = &Config{
		MemoryKB:    uint32(m),
		Times:       uint32(t),
		Parallelism: uint8(p),
		SaltLength:  uint32(len(salt)),
		KeyLength:   uint32(len(hash)),
	}

	return cfg, salt, hash, nil
}
